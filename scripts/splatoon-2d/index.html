<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Splatoon 2D (左パッドエイム版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden;
            touch-action: none; 
        }
        #gameContainer {
            background-color: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            text-align: center;
            width: 100%;
            max-width: 700px; 
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #e0e0e0; 
            border-radius: 8px;
            max-width: 100%;
            height: auto;
        }
        .ui-element {
            font-size: clamp(0.8rem, 2.5vw, 1.1rem); 
            color: #333;
            margin: 3px 0;
        }
        .button {
            background-color: #4A90E2; 
            color: white;
            padding: 8px 16px; 
            border: none;
            border-radius: 8px;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 8px;
        }
        .button:hover {
            background-color: #357ABD;
        }
        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #messageBox {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            text-align: center;
            z-index: 1000; 
            width: 80%;
            max-width: 400px;
        }

        /* Virtual Pad Styles */
        #touchControlsContainer {
            display: none; /* Hidden by default, shown by @media */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: clamp(150px, 35vh, 200px); /* Adjusted height */
            padding: 10px 20px; /* Added horizontal padding */
            box-sizing: border-box;
            justify-content: space-between; /* Space between move pad and action buttons */
            align-items: center;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            z-index: 500; 
        }

        .virtual-pad-area { /* Only for move pad now */
            width: clamp(120px, 30vw, 160px); /* Slightly smaller max size */
            height: clamp(120px, 30vw, 160px);
            background-color: rgba(100, 100, 100, 0.2);
            border-radius: 50%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .virtual-pad-knob { /* Only for move pad knob */
            width: clamp(50px, 12vw, 60px); /* Slightly smaller max size */
            height: clamp(50px, 12vw, 60px);
            background-color: rgba(50, 50, 50, 0.5);
            border-radius: 50%;
            position: absolute;
            pointer-events: none; 
        }
        
        #actionButtonsRight {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-around; /* Distribute space for buttons */
            height: 100%; /* Take full height of the container */
        }

        .action-button-touch {
            width: clamp(65px, 18vw, 80px); /* Slightly larger buttons */
            height: clamp(65px, 18vw, 80px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(13px, 3.2vw, 15px);
            color: white;
            cursor: pointer;
            border: 2px solid;
            -webkit-tap-highlight-color: transparent;
            margin: 8px 0; /* Increased margin */
        }
        #touchShootButton {
            background-color: rgba(248, 113, 113, 0.8); 
            border-color: #ef4444;
        }
        #touchSubmergeButton {
            background-color: rgba(250, 204, 21, 0.8); 
            border-color: #eab308;
        }


        @media (pointer: coarse) { 
            #touchControlsContainer {
                display: flex;
            }
            .mouse-instructions {
                display: none;
            }
            #gameContainer {
                padding-bottom: clamp(170px, 39vh, 240px); /* Adjusted padding for controls */
            }
        }
        @media (pointer: fine) {
            #startButton {
                display: none;
            }
        }

        .logo-title {
            font-weight: 900; 
            font-size: clamp(1.8rem, 7vw, 2.8rem); 
            margin-bottom: 0.5rem;
        }
        .logo-splat {
            color: #EC4899; 
            text-shadow: 1px 1px 0px #c026d3; 
        }
        .logo-toon {
            color: #84CC16; 
            text-shadow: 1px 1px 0px #4d7c0f; 
        }
        .logo-2d {
            color: #3B82F6; 
            font-size: clamp(1.5rem, 6vw, 2.4rem);
            margin-left: 5px;
            text-shadow: 1px 1px 0px #1d4ed8; 
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 class="logo-title">
            <span class="logo-splat">Spla</span><span class="logo-toon">toon</span> <span class="logo-2d">2D</span>
        </h1>
        
        <div class="grid grid-cols-2 md:grid-cols-4 gap-1 md:gap-2 mb-2 md:mb-3">
            <div id="timerDisplay" class="ui-element">時間: 60秒</div>
            <div id="inkDisplay" class="ui-element">インク: 100</div>
            <div id="scoreDisplay" class="ui-element">自スコア: 0%</div>
            <div id="enemyScoreDisplay" class="ui-element">敵スコア: 0%</div>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        <div id="controls" class="mt-2 md:mt-3">
            <button id="startButton" class="button">ゲーム開始</button>
            <button id="restartButton" class="button" style="display:none;">もう一度プレイ</button>
        </div>
        
        <div id="messageBox" style="display:none;"></div>

         <p class="mt-2 text-xs md:text-sm text-gray-600 mouse-instructions">
            操作: 矢印/WASDで移動、マウスクリック長押しでインク連続発射、Shiftキーで潜伏。<br>
            <span id="pcStartInstruction">スペースキーでゲーム開始/リスタート。</span>
         </p>
         <p class="mt-1 text-xs md:text-sm text-gray-600">
            タッチ操作: 左パッドで移動・エイム、右のボタンでアクション。
         </p>
    </div>

    <div id="touchControlsContainer">
        <div id="movePadArea" class="virtual-pad-area">
            <div id="movePadKnob" class="virtual-pad-knob"></div>
        </div>
        <div id="actionButtonsRight">
            <div id="touchShootButton" class="action-button-touch">塗る</div>
            <div id="touchSubmergeButton" class="action-button-touch">潜る</div>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 400;
        const GRID_CELL_SIZE = 10;
        
        const PLAYER_COLOR = 'rgba(59, 130, 246, 1)'; 
        const PLAYER_SUBMERGED_COLOR = 'rgba(59, 130, 246, 0.5)'; 
        const ENEMY_COLOR = 'rgba(239, 68, 68, 1)';   
        const PLAYER_RADIUS = GRID_CELL_SIZE * 0.8;
        const PLAYER_SPEED = 2.5; 
        const PLAYER_SUBMERGED_SPEED_MULTIPLIER = 1.5; 
        const PLAYER_ON_ENEMY_INK_SPEED_MULTIPLIER = 0.5;
        
        const NEUTRAL_COLOR = 'rgba(224, 224, 224, 1)';
        const BORDER_COLOR = 'rgba(100, 100, 100, 1)';
        
        const INK_SPLAT_RADIUS = GRID_CELL_SIZE * 1.5;
        const INK_PROJECTILE_SPEED = 6;
        const INK_PROJECTILE_RADIUS = 4;
        const MAX_INK = 100;
        const INK_COST_PER_SHOT = 5; 
        const INK_REFILL_RATE_NORMAL = 0.05; 
        const INK_REFILL_RATE_WHILE_SUBMERGED = 0.4; 
        const SHOT_COOLDOWN = 8; 
        const MAX_PROJECTILE_DISTANCE = 150; 

        const GAME_DURATION_SECONDS = 60;

        // Enemy Configuration
        const ENEMY_RADIUS = GRID_CELL_SIZE * 0.8;
        const ENEMY_SPEED = 2.0;
        const ENEMY_SHOT_COOLDOWN = 75; 
        const ENEMY_STUN_DURATION = 120; 
        const ENEMY_MOVE_INTERVAL = 90; 
        const ENEMY_AI_MODE_CHANGE_INTERVAL = 240; 
        const ENEMY_PAINT_TARGET_RADIUS = 100; 
        const ENEMY_PLAYER_DETECTION_RADIUS = 200; 

        // --- Game Variables ---
        let canvas, ctx;
        let player; 
        let enemy; 
        let projectiles = [];
        let mapGrid; 
        let currentInk = MAX_INK;
        let playerScore = 0;
        let enemyScore = 0; 
        let timeLeft = GAME_DURATION_SECONDS;
        let gameInterval;
        let shotCooldownTimer = 0;
        let keysPressed = {}; 
        let mousePos = { x: 0, y: 0 }; 
        let isGameOver = true;
        let animationFrameId;
        
        let moveInput = { x: 0, y: 0, active: false, identifier: null, lastNonZeroX: 1, lastNonZeroY: 0 }; // Added lastNonZero for default aim
        // let aimInput = { x: 0, y: 0, active: false, identifier: null }; // Removed aimInput
        let playerAimAngle = 0; // Will be derived from moveInput or mouse

        let isTouchSubmergeActive = false;
        let isShooting = false; 

        // --- DOM Elements ---
        const timerDisplay = document.getElementById('timerDisplay');
        const inkDisplay = document.getElementById('inkDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const enemyScoreDisplay = document.getElementById('enemyScoreDisplay'); 
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const messageBox = document.getElementById('messageBox');
        const gameCanvas = document.getElementById('gameCanvas');
        const pcStartInstruction = document.getElementById('pcStartInstruction');
        
        const movePadArea = document.getElementById('movePadArea');
        const movePadKnob = document.getElementById('movePadKnob');
        // const aimPadArea = document.getElementById('aimPadArea'); // Removed
        // const aimPadKnob = document.getElementById('aimPadKnob'); // Removed
        const touchShootButtonElement = document.getElementById('touchShootButton'); 
        const touchSubmergeButtonElement = document.getElementById('touchSubmergeButton'); 


        // --- Game Classes ---
        class Character { 
            constructor(x, y, radius, color, speed) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.baseColor = color; 
                this.color = color;
                this.speed = speed;
                this.stunTimer = 0; 
            }

            draw() {
                if (this.stunTimer > 0 && Math.floor(this.stunTimer / 10) % 2 === 0) {
                    return;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1.5; 
                ctx.stroke();
            }
            
            move(dx, dy, currentSpeedMultiplier = 1) { 
                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    return;
                }
                this.x += dx * this.speed * currentSpeedMultiplier;
                this.y += dy * this.speed * currentSpeedMultiplier;
                this.x = Math.max(this.radius, Math.min(this.x, CANVAS_WIDTH - this.radius));
                this.y = Math.max(this.radius, Math.min(this.y, CANVAS_HEIGHT - this.radius));
            }

            shoot(targetX, targetY, projectileColor) { 
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                const velocityX = Math.cos(angle) * INK_PROJECTILE_SPEED;
                const velocityY = Math.sin(angle) * INK_PROJECTILE_SPEED;
                projectiles.push(new Projectile(this.x, this.y, INK_PROJECTILE_RADIUS, projectileColor, velocityX, velocityY, this instanceof Player, this.x, this.y));
            }

            isStunned() {
                return this.stunTimer > 0;
            }

            applyStun(duration) {
                this.stunTimer = duration;
            }

            getCurrentGridCell() {
                const gridX = Math.floor(this.x / GRID_CELL_SIZE);
                const gridY = Math.floor(this.y / GRID_CELL_SIZE);
                if (mapGrid && mapGrid[gridY] && mapGrid[gridY][gridX] !== undefined) {
                    return { x: gridX, y: gridY, color: mapGrid[gridY][gridX] };
                }
                return null; 
            }
        }

        class Player extends Character {
            constructor(x, y, radius, color, speed) {
                super(x, y, radius, color, speed);
                this.isSubmerged = false;
                this.originalRadius = radius;
            }

            update() {
                if (this.isStunned()) {
                    this.stunTimer--;
                    this.emerge(); 
                    return;
                }

                let dx = 0;
                let dy = 0;

                if (keysPressed['arrowup'] || keysPressed['w']) dy -= 1;
                if (keysPressed['arrowdown'] || keysPressed['s']) dy += 1;
                if (keysPressed['arrowleft'] || keysPressed['a']) dx -= 1;
                if (keysPressed['arrowright'] || keysPressed['d']) dx += 1;

                if (moveInput.active) {
                    dx = moveInput.x;
                    dy = moveInput.y;
                }
                
                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    dx /= length;
                    dy /= length;
                    moveInput.lastNonZeroX = dx; // Store last actual movement direction
                    moveInput.lastNonZeroY = dy;
                }
                
                let currentSpeedMultiplier = 1;
                const currentCell = this.getCurrentGridCell();

                if (this.isSubmerged) {
                    currentSpeedMultiplier *= PLAYER_SUBMERGED_SPEED_MULTIPLIER;
                }
                
                if (currentCell && currentCell.color === ENEMY_COLOR) {
                    currentSpeedMultiplier *= PLAYER_ON_ENEMY_INK_SPEED_MULTIPLIER;
                    if (this.isSubmerged) this.emerge(); 
                }
                
                this.move(dx, dy, currentSpeedMultiplier); 

                if (keysPressed['shift'] || isTouchSubmergeActive) {
                    this.trySubmerge();
                } else {
                    this.emerge();
                }

                if (this.isSubmerged && (!this.isOnOwnInk() || (currentCell && currentCell.color === ENEMY_COLOR))) {
                    this.emerge();
                }

                // Aiming logic
                if (isTouchDevice()) {
                    // On touch devices, aim based on moveInput's last known direction
                    if (moveInput.active && (moveInput.x !== 0 || moveInput.y !== 0)) {
                         playerAimAngle = Math.atan2(moveInput.y, moveInput.x);
                    } else {
                        // If not actively moving via pad, use the last non-zero direction
                        playerAimAngle = Math.atan2(moveInput.lastNonZeroY, moveInput.lastNonZeroX);
                    }
                } else { // PC: use mouse
                    const canvasRect = gameCanvas.getBoundingClientRect();
                    if (canvasRect.width === 0 || canvasRect.height === 0) return; 
                    
                    const scaledMouseX = mousePos.x * (CANVAS_WIDTH / canvasRect.width);
                    const scaledMouseY = mousePos.y * (CANVAS_HEIGHT / canvasRect.height);

                    const aimTargetX = scaledMouseX - this.x; 
                    const aimTargetY = scaledMouseY - this.y;
                    if (aimTargetX !== 0 || aimTargetY !== 0) { 
                         playerAimAngle = Math.atan2(aimTargetY, aimTargetX);
                    }
                }
            }

            attemptShoot() { 
                if (this.isSubmerged || this.isStunned()) return false;
                if (currentInk >= INK_COST_PER_SHOT && shotCooldownTimer <= 0) {
                    const targetX = this.x + Math.cos(playerAimAngle) * 50; 
                    const targetY = this.y + Math.sin(playerAimAngle) * 50;
                    super.shoot(targetX, targetY, this.baseColor); 
                    currentInk -= INK_COST_PER_SHOT;
                    shotCooldownTimer = SHOT_COOLDOWN; 
                    return true;
                }
                return false;
            }

            trySubmerge() {
                const currentCell = this.getCurrentGridCell();
                if (this.isOnOwnInk() && !this.isSubmerged && (!currentCell || currentCell.color !== ENEMY_COLOR)) {
                    this.isSubmerged = true;
                    this.color = PLAYER_SUBMERGED_COLOR;
                    this.radius = this.originalRadius * 0.7; 
                }
            }

            emerge() {
                if (this.isSubmerged) {
                    this.isSubmerged = false;
                    this.color = this.baseColor;
                    this.radius = this.originalRadius;
                }
            }

            isOnOwnInk() {
                const cell = this.getCurrentGridCell();
                return cell && cell.color === this.baseColor;
            }
        }

        class Enemy extends Character { 
             constructor(x, y, radius, color, speed) {
                super(x, y, radius, color, speed);
                this.shotCooldown = ENEMY_SHOT_COOLDOWN;
                this.moveDirectionTimer = ENEMY_MOVE_INTERVAL;
                this.aiModeTimer = ENEMY_AI_MODE_CHANGE_INTERVAL;
                this.aiMode = 'paint'; 
                this.currentDx = 0;
                this.currentDy = 0;
                this.targetPaintPos = null; 
                this.setRandomDirection();
            }

            update(playerInstance) { 
                if (this.isStunned()) {
                    this.stunTimer--;
                    return;
                }

                this.aiModeTimer--;
                if (this.aiModeTimer <= 0) {
                    this.switchAiMode(playerInstance);
                    this.aiModeTimer = ENEMY_AI_MODE_CHANGE_INTERVAL * (0.8 + Math.random() * 0.4);
                }
                
                this.moveDirectionTimer--;
                if (this.moveDirectionTimer <= 0 || (this.aiMode === 'paint' && this.targetPaintPos && Math.hypot(this.x - this.targetPaintPos.x, this.y - this.targetPaintPos.y) < GRID_CELL_SIZE * 2)) {
                    if (this.aiMode === 'paint') {
                        this.findPaintTarget();
                        if (this.targetPaintPos) {
                            const angleToPaint = Math.atan2(this.targetPaintPos.y - this.y, this.targetPaintPos.x - this.x);
                            this.currentDx = Math.cos(angleToPaint);
                            this.currentDy = Math.sin(angleToPaint);
                        } else {
                             this.setRandomDirection(); 
                        }
                    } else { 
                        if (playerInstance) {
                            const angleToPlayer = Math.atan2(playerInstance.y - this.y, playerInstance.x - this.x);
                            this.currentDx = Math.cos(angleToPlayer) * (0.7 + Math.random() * 0.3); 
                            this.currentDy = Math.sin(angleToPlayer) * (0.7 + Math.random() * 0.3);
                            if (Math.random() < 0.3) this.setRandomDirection(); 
                        } else {
                            this.setRandomDirection();
                        }
                    }
                    this.moveDirectionTimer = ENEMY_MOVE_INTERVAL * (0.5 + Math.random());
                }
                
                let currentSpeedMultiplier = 1;
                const currentCell = this.getCurrentGridCell();
                 if (currentCell && currentCell.color === PLAYER_COLOR) { 
                    currentSpeedMultiplier = PLAYER_ON_ENEMY_INK_SPEED_MULTIPLIER; 
                }
                this.move(this.currentDx, this.currentDy, currentSpeedMultiplier);

                this.shotCooldown--;
                if (this.shotCooldown <= 0 && playerInstance) { 
                    let shootTargetX, shootTargetY;
                    if (this.aiMode === 'attack' || Math.hypot(this.x - playerInstance.x, this.y - playerInstance.y) < ENEMY_PLAYER_DETECTION_RADIUS / 1.5) { 
                        shootTargetX = playerInstance.x;
                        shootTargetY = playerInstance.y;
                    } else if (this.targetPaintPos) { 
                        shootTargetX = this.targetPaintPos.x;
                        shootTargetY = this.targetPaintPos.y;
                    } else { 
                        shootTargetX = this.x + this.currentDx * 50;
                        shootTargetY = this.y + this.currentDy * 50;
                    }
                    this.shoot(shootTargetX, shootTargetY, this.baseColor);
                    this.shotCooldown = ENEMY_SHOT_COOLDOWN * (0.8 + Math.random() * 0.4); 
                }
            }
            
            switchAiMode(playerInstance) {
                if (!playerInstance) {
                    this.aiMode = 'paint';
                    this.findPaintTarget();
                    return;
                }
                const distToPlayer = Math.hypot(this.x - playerInstance.x, this.y - playerInstance.y);
                if (distToPlayer < ENEMY_PLAYER_DETECTION_RADIUS) {
                    this.aiMode = 'attack';
                } else {
                    this.aiMode = (Math.random() < 0.75) ? 'paint' : 'attack'; 
                }
                if (this.aiMode === 'paint') {
                    this.findPaintTarget();
                }
            }

            findPaintTarget() {
                let bestTarget = null;
                let maxScore = -1;
                if (!mapGrid || mapGrid.length === 0 || !mapGrid[0]) return; 
                for (let i = 0; i < 15; i++) { 
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * ENEMY_PAINT_TARGET_RADIUS * 1.5; 
                    const checkX = this.x + Math.cos(angle) * dist;
                    const checkY = this.y + Math.sin(angle) * dist;

                    const gridX = Math.floor(checkX / GRID_CELL_SIZE);
                    const gridY = Math.floor(checkY / GRID_CELL_SIZE);

                    if (gridX >= 0 && gridX < mapGrid[0].length && gridY >=0 && gridY < mapGrid.length) {
                        const cellColor = mapGrid[gridY][gridX];
                        let currentScore = 0;
                        if (cellColor === NEUTRAL_COLOR) currentScore = 3; 
                        else if (cellColor === PLAYER_COLOR) currentScore = 1; 
                        else if (cellColor !== this.baseColor) currentScore = 2; 

                        if (currentScore > maxScore) {
                            maxScore = currentScore;
                            bestTarget = { x: checkX, y: checkY };
                        }
                    }
                }
                this.targetPaintPos = bestTarget;
            }
            
            setRandomDirection() {
                const angle = Math.random() * Math.PI * 2;
                this.currentDx = Math.cos(angle);
                this.currentDy = Math.sin(angle);
            }
        }


        class Projectile {
             constructor(x, y, radius, color, velocityX, velocityY, isPlayerProjectile, startX, startY) { 
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.isPlayerProjectile = isPlayerProjectile; 
                this.startX = startX; 
                this.startY = startY; 
                this.distanceTraveled = 0; 
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            update() {
                const prevX = this.x;
                const prevY = this.y;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.distanceTraveled += Math.hypot(this.x - prevX, this.y - prevY); 

                if (this.distanceTraveled > MAX_PROJECTILE_DISTANCE) {
                    return true; 
                }

                if (this.isPlayerProjectile && enemy) { 
                    const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (dist < this.radius + enemy.radius && !enemy.isStunned()) {
                        enemy.applyStun(ENEMY_STUN_DURATION);
                        return true; 
                    }
                } else if (!this.isPlayerProjectile && player) { 
                     const dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < this.radius + player.radius && !player.isSubmerged && !player.isStunned()) { 
                        player.applyStun(ENEMY_STUN_DURATION / 2); 
                        return true; 
                    }
                }

                if (this.x > 0 && this.x < CANVAS_WIDTH && this.y > 0 && this.y < CANVAS_HEIGHT) {
                     inkArea(this.x, this.y, INK_SPLAT_RADIUS, this.color);
                } else { 
                    return true; 
                }
                
                if (this.x < -this.radius * 5 || this.x > CANVAS_WIDTH + this.radius * 5 || 
                    this.y < -this.radius * 5 || this.y > CANVAS_HEIGHT + this.radius * 5) {
                    return true; 
                }
                return false;
            }
        }

        // --- Game Logic Functions ---
        function initGame() {
            canvas = gameCanvas;
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            ctx = canvas.getContext('2d');

            player = new Player(CANVAS_WIDTH / 4, CANVAS_HEIGHT / 2, PLAYER_RADIUS, PLAYER_COLOR, PLAYER_SPEED);
            enemy = new Enemy(CANVAS_WIDTH * 3 / 4, CANVAS_HEIGHT / 2, ENEMY_RADIUS, ENEMY_COLOR, ENEMY_SPEED); 
            
            mapGrid = [];
            for (let r = 0; r < CANVAS_HEIGHT / GRID_CELL_SIZE; r++) {
                mapGrid[r] = [];
                for (let c = 0; c < CANVAS_WIDTH / GRID_CELL_SIZE; c++) {
                    mapGrid[r][c] = NEUTRAL_COLOR;
                }
            }
            
            projectiles = [];
            currentInk = MAX_INK;
            playerScore = 0;
            enemyScore = 0; 
            timeLeft = GAME_DURATION_SECONDS;
            shotCooldownTimer = 0;
            isGameOver = false;
            isTouchSubmergeActive = false;
            isShooting = false; 
            keysPressed = {}; 
            moveInput = { x: 0, y: 0, active: false, identifier: null, lastNonZeroX: 1, lastNonZeroY: 0 }; 
            // aimInput removed
            playerAimAngle = 0; 

            updateUI();
            messageBox.style.display = 'none';
            restartButton.style.display = 'none'; 

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
            
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(updateTimer, 1000);
        }

        function gameLoop() {
            if (isGameOver) {
                drawGameOver();
                return;
            }

            player.update();
            if (enemy) enemy.update(player); 
            
            projectiles = projectiles.filter(p => !p.update());

            if (shotCooldownTimer > 0) {
                shotCooldownTimer--;
            }
            
            if (isShooting && player) {
                player.attemptShoot(); 
            }

            if (player.isSubmerged && player.isOnOwnInk()) {
                const currentCell = player.getCurrentGridCell();
                if (!currentCell || currentCell.color !== ENEMY_COLOR) { 
                     currentInk = Math.min(MAX_INK, currentInk + INK_REFILL_RATE_WHILE_SUBMERGED);
                }
            } else if (!player.isSubmerged) { 
                 currentInk = Math.min(MAX_INK, currentInk + INK_REFILL_RATE_NORMAL);
            }


            clearCanvas();
            drawMap();
            if (enemy) enemy.draw(); 
            player.draw(); 
            projectiles.forEach(p => p.draw());
            drawVirtualPadKnobs(); 

            updateUI();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function clearCanvas() {
            ctx.fillStyle = NEUTRAL_COLOR; 
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        function drawMap() {
            if (!mapGrid || mapGrid.length === 0) return; 
            for (let r = 0; r < mapGrid.length; r++) {
                for (let c = 0; c < mapGrid[r].length; c++) {
                    if (mapGrid[r][c] !== NEUTRAL_COLOR) {
                        ctx.fillStyle = mapGrid[r][c];
                        ctx.fillRect(c * GRID_CELL_SIZE, r * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE);
                    }
                }
            }
        }
        
        function inkArea(worldX, worldY, radius, color) {
            if (!mapGrid || mapGrid.length === 0 || !mapGrid[0]) return;
            const startCol = Math.max(0, Math.floor((worldX - radius) / GRID_CELL_SIZE));
            const endCol = Math.min(mapGrid[0].length - 1, Math.floor((worldX + radius) / GRID_CELL_SIZE));
            const startRow = Math.max(0, Math.floor((worldY - radius) / GRID_CELL_SIZE));
            const endRow = Math.min(mapGrid.length - 1, Math.floor((worldY + radius) / GRID_CELL_SIZE));

            for (let r = startRow; r <= endRow; r++) {
                for (let c = startCol; c <= endCol; c++) {
                    mapGrid[r][c] = color;
                }
            }
            calculateScores(); 
        }

        function calculateScores() { 
            let pScore = 0;
            let eScore = 0;
            if (!mapGrid || mapGrid.length === 0 || !mapGrid[0]) return;
            const totalCells = mapGrid.length * mapGrid[0].length;
            if (totalCells === 0) return; 

            for (let r = 0; r < mapGrid.length; r++) {
                for (let c = 0; c < mapGrid[r].length; c++) {
                    if (mapGrid[r][c] === PLAYER_COLOR) {
                        pScore++;
                    } else if (mapGrid[r][c] === ENEMY_COLOR) {
                        eScore++;
                    }
                }
            }
            playerScore = Math.round((pScore / totalCells) * 100);
            enemyScore = Math.round((eScore / totalCells) * 100);
        }

        function updateUI() {
            timerDisplay.textContent = `時間: ${timeLeft}秒`;
            inkDisplay.textContent = `インク: ${Math.floor(currentInk)}`;
            scoreDisplay.textContent = `自スコア: ${playerScore}%`;
            enemyScoreDisplay.textContent = `敵スコア: ${enemyScore}%`; 
        }

        function updateTimer() {
            if (isGameOver) return;
            timeLeft--;
            if (timeLeft <= 0) {
                timeLeft = 0;
                endGame();
            }
            updateUI();
        }

        function endGame() {
            isGameOver = true;
            isShooting = false; 
            clearInterval(gameInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            let resultMessage = `ゲームオーバー！<br>自スコア: ${playerScore}% | 敵スコア: ${enemyScore}%<br>`;
            if (playerScore > enemyScore) {
                resultMessage += "あなたの勝ち！";
            } else if (enemyScore > playerScore) {
                resultMessage += "あなたの負け...";
            } else {
                resultMessage += "引き分け！";
            }
            messageBox.innerHTML = resultMessage;
            messageBox.style.display = 'block';
            restartButton.style.display = 'inline-block'; 
        }
        
        function drawGameOver() {
            clearCanvas();
            drawMap(); 
            if(player) player.draw(); 
            if(enemy) enemy.draw();
            messageBox.style.display = 'block'; 
        }

        // --- Input Event Listeners ---
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (isGameOver) {
                if (key === " " || key === "enter") {
                    if (restartButton.style.display !== 'none') {
                        initGame();
                        e.preventDefault(); 
                    } 
                    else if (!player && !isTouchDevice()) { 
                        initGame();
                        e.preventDefault();
                    }
                }
                return; 
            }
            
            keysPressed[key] = true; 
            if (["arrowup", "arrowdown", "arrowleft", "arrowright", " ", "shift", "w", "a", "s", "d"].includes(key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = false;
        });

        gameCanvas.addEventListener('mousedown', (e) => {
            if (isGameOver || e.button !== 0 || isTouchDevice()) return; 
            isShooting = true;
            e.preventDefault(); 
        });
        gameCanvas.addEventListener('mouseup', (e) => {
            if (e.button !== 0 || isTouchDevice()) return;
            isShooting = false;
        });
        gameCanvas.addEventListener('mouseleave', (e) => { 
             if (!isTouchDevice()) isShooting = false;
        });


        gameCanvas.addEventListener('mousemove', (e) => {
            if (isGameOver || isTouchDevice()) return; 
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        });
        
        function isTouchDevice() {
            return (('ontouchstart' in window) || 
                    (navigator.maxTouchPoints > 0) || 
                    (navigator.msMaxTouchPoints > 0) ||
                    (window.DocumentTouch && document instanceof DocumentTouch));
        }

        function drawVirtualPadKnobs() {
            // Only draw move pad knob if on touch device and controls are visible
            if (!isTouchDevice() || !movePadArea.offsetParent ) return; 

            const moveRect = movePadArea.getBoundingClientRect();
            let knobMoveX = moveRect.width / 2;
            let knobMoveY = moveRect.height / 2;
            if (moveInput.active) {
                knobMoveX += moveInput.x * (moveRect.width / 3.5); 
                knobMoveY += moveInput.y * (moveRect.height / 3.5);
            }
            movePadKnob.style.left = `${knobMoveX - movePadKnob.offsetWidth / 2}px`;
            movePadKnob.style.top = `${knobMoveY - movePadKnob.offsetHeight / 2}px`;
        }


        function handlePadStart(event, padState, padKnobElement, padAreaElement) {
            event.preventDefault();
            if (padState.identifier !== null && padState.active) return; 

            const touch = event.changedTouches[0];
            padState.identifier = touch.identifier;
            padState.active = true;
            updatePadInput(touch, padState, padKnobElement, padAreaElement);
        }

        function handlePadMove(event, padState, padKnobElement, padAreaElement) {
            event.preventDefault();
            if (!padState.active) return;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === padState.identifier) {
                    updatePadInput(touch, padState, padKnobElement, padAreaElement);
                    break;
                }
            }
        }

        function handlePadEnd(event, padState, padKnobElement) {
            event.preventDefault();
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === padState.identifier) {
                    padState.active = false;
                    // Don't reset x, y here to keep last direction for aiming if pad is released
                    // padState.x = 0; 
                    // padState.y = 0;
                    padState.identifier = null;
                    break;
                }
            }
        }
        
        function updatePadInput(touch, padState, padKnobElement, padAreaElement) {
            const rect = padAreaElement.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            let dx = touchX - rect.width / 2;
            let dy = touchY - rect.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) { 
                padState.x = 0;
                padState.y = 0;
                return;
            }

            padState.x = dx / distance;
            padState.y = dy / distance;
        }

        movePadArea.addEventListener('touchstart', (e) => handlePadStart(e, moveInput, movePadKnob, movePadArea), { passive: false });
        movePadArea.addEventListener('touchmove', (e) => handlePadMove(e, moveInput, movePadKnob, movePadArea), { passive: false });
        movePadArea.addEventListener('touchend', (e) => handlePadEnd(e, moveInput, movePadKnob), { passive: false });
        movePadArea.addEventListener('touchcancel', (e) => handlePadEnd(e, moveInput, movePadKnob), { passive: false });

        // Aim Pad Listeners Removed

        touchShootButtonElement.addEventListener('touchstart', (e) => { 
            e.preventDefault();
            if (isGameOver || !player) return;
            isShooting = true; 
        }, { passive: false });
        touchShootButtonElement.addEventListener('touchend', (e) => {
            e.preventDefault();
            isShooting = false;
        }, { passive: false });
        touchShootButtonElement.addEventListener('touchcancel', (e) => { 
            e.preventDefault();
            isShooting = false;
        }, { passive: false });


        touchSubmergeButtonElement.addEventListener('touchstart', (e) => { 
            e.preventDefault();
            if (isGameOver || !player) return;
            isTouchSubmergeActive = true;
            player.trySubmerge();
        }, { passive: false });
        touchSubmergeButtonElement.addEventListener('touchend', (e) => { 
            e.preventDefault();
            if (isGameOver || !player) return;
            isTouchSubmergeActive = false;
            if (!keysPressed['shift']) { 
                 player.emerge();
            }
        }, { passive: false });


        // --- Initial Setup ---
        function showInitialCanvasMessage() {
            if (!canvas) { 
                canvas = gameCanvas;
                canvas.width = CANVAS_WIDTH; 
                canvas.height = CANVAS_HEIGHT; 
            }
            resizeCanvas(); 

            ctx = canvas.getContext('2d');
            clearCanvas(); 
            
            const isTouch = isTouchDevice();
            const message = isTouch ? "「ゲーム開始」ボタンを押してスタート！" : "スペースキーを押してスタート！";
            if (pcStartInstruction) {
                 pcStartInstruction.style.display = isTouch ? 'none' : 'inline';
            }
            if (startButton && !isTouch) { 
                startButton.style.display = 'none';
            }


            ctx.fillStyle = 'black';
            ctx.font = '20px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(message, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            updateUI(); 
        }
        
        const gameContainer = document.getElementById('gameContainer');
        function resizeCanvas() {
            if (!canvas) return;
            const containerWidth = gameContainer.clientWidth - parseInt(window.getComputedStyle(gameContainer).paddingLeft) - parseInt(window.getComputedStyle(gameContainer).paddingRight);
            const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            let newWidth = containerWidth;
            let newHeight = containerWidth / aspectRatio;

            const touchControlsContainer = document.getElementById('touchControlsContainer');
            const touchControlsHeight = isTouchDevice() && touchControlsContainer ? parseFloat(getComputedStyle(touchControlsContainer).height) : 0;
            
            let availableHeight = window.innerHeight;
            const uiElements = [
                document.querySelector('h1'),
                document.querySelector('.grid'), 
                document.getElementById('controls'), 
                ...document.querySelectorAll('#gameContainer > p') 
            ];
            uiElements.forEach(el => {
                if (el && el.offsetParent !== null) availableHeight -= el.offsetHeight; 
            });
            availableHeight -= (parseInt(window.getComputedStyle(gameContainer).paddingTop) + parseInt(window.getComputedStyle(gameContainer).paddingBottom));
            availableHeight -= touchControlsHeight;
            availableHeight -= 20; 

            if (newHeight > availableHeight && availableHeight > 0) { 
                newHeight = availableHeight;
                newWidth = newHeight * aspectRatio;
            }
             if (newWidth > containerWidth) { 
                newWidth = containerWidth;
                newHeight = newWidth / aspectRatio;
            }
            
            canvas.style.width = `${Math.max(100, newWidth)}px`; 
            canvas.style.height = `${Math.max(100 / aspectRatio, newHeight)}px`;
        }

        window.onload = () => {
            showInitialCanvasMessage(); 
            window.addEventListener('resize', resizeCanvas); 
            if (isTouchDevice()) {
                requestAnimationFrame(drawVirtualPadKnobs); 
                 if (pcStartInstruction) pcStartInstruction.style.display = 'none';
                 if (startButton) startButton.style.display = 'inline-block'; 
            } else {
                if (startButton) startButton.style.display = 'none'; 
                if (pcStartInstruction) pcStartInstruction.style.display = 'inline';
            }
        };
        if (startButton) {
            startButton.addEventListener('click', () => {
                if (isGameOver && (!player || restartButton.style.display !== 'none')) {
                    initGame();
                }
            });
        }
    </script>
</body>
</html>

